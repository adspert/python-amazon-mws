.. _page_parsed_attr:

Using Parsed XML Responses
##########################

For most MWS operations, the returned response is an XML documents `encoded using ISO 8859-1
<http://docs.developer.amazonservices.com/en_US/dev_guide/DG_ISO8859.html>`_. Python-Amazon-MWS will wrap all responses
in a ``mws.response.MWSResponse`` object, which then parses these responses automatically using the ``xmltodict``
package. This parsed content is then available as ``response.parsed``.

Below, we'll go into more detail on how to use ``response.parsed`` in your application to get the most from
these XML responses.

.. note:: Throughout these docs, we refer to an instance of ``MWSResponse`` as ``response``. This should not be
   confused with |requests_response_link|_, which is often referred to be the same name.

.. note:: If you wish to work with the raw XML response returned from MWS, you can access it through one of the
   following methods:

   - The property ``MWSResponse.original`` returns the original ``requests.Response`` object generated by the request
     to MWS. Use either ``MWSResponse.original.content`` (for bytes) or ``MWSResponse.original.text`` (for Unicode)
     to work with the raw XML.

     - ``MWSResponse.original`` is also aliased as property ``MWSResponse.response``. The same interface is available
       at either property.

   - The real ``requests.Response`` object can be found at ``MWSResponse._response``, in case changes to the content
     are required. ``.content`` and ``.text`` can be accessed from here, as well.
   - ``MWSResponse`` provides properties that act as shortcuts to some of the attrs of ``requests.Response``, including
     ``.headers``, ``.status_code``, etc. ``MWSResponse.content`` and ``MWSResponse.text`` will return the same
     values as ``MWSResponse.original.content`` and ``MWSResponse.original.text``, respectively.

   Note also that Python-Amazon-MWS will set ``.original.encoding`` to ``"iso-8859-1"`` explicitly. You can alter this
   by setting the value of ``MWSResponse._response.encoding``, and can check the encoding that ``requests`` has
   guessed for the content by reading ``MWSResponse._response.apparent_encoding`` (`docs link
   <https://2.python-requests.org/en/master/api/#requests.Response.apparent_encoding>`_).

   **So**, if you wish to process the raw XML document yourself, you can work with any of the above methods to
   get to the original response's ``.content`` (for bytes) or ``.text`` (for Unicode).

.. |requests_response_link| replace:: an instance of ``requests.Response`` from the ``requests`` package
.. _requests_response_link: https://2.python-requests.org/en/master/api/#requests.Response

Dictionary keys as attributes
=============================

``response.parsed`` returns an instance of ``mws.utils.collections.DotDict``, a subclass of ``dict`` that allows
its keys to be accessed as attributes as well as standard ``dict`` keys:

.. code-block:: python

    from mws.utils.collections import DotDict

    foo = DotDict({'bar': {'baz': 'spam'}})
    print(foo.bar.baz)
    # 'spam'

This is useful for MWS responses and parsed XML documents in particular, which may have tags with long names
and deeply-nested structures.

Consider the following (truncated and edited) example response from the MWS operation ``ListMatchingProducts``:

.. code-block:: xml

    <?xml version="1.0"?>
    <ListMatchingProductsResponse xmlns="http://mws.amazonservices.com/schema/Products/2011-10-01">
      <ListMatchingProductsResult>
        <Products>
          <Product>
            <Identifiers>
              <MarketplaceASIN>
                <MarketplaceId>ACBDEFGH</MarketplaceId>
                <ASIN>B0987654</ASIN>
              </MarketplaceASIN>
            </Identifiers>
            <AttributeSets>
              ...
            </AttributeSets>
          </Product>
          <Product>
            ...
          </Product>
        </Products>
      </ListMatchingProductsResult>
    </ListMatchingProductsResponse>

When this document is parsed to a standard ``dict``, accessing the ASIN of the first Product requires code like:

.. code-block:: python

    asin = parsed_dict['Products']['Product'][0]['Identifiers']['MarketplaceASIN']['ASIN']

Using a ``DotDict``, the same content can be accessed by specifying attributes by the same names as the keys:

.. code-block:: python

    asin = response.parsed.Products.Product[0].Identifiers.MarketplaceASIN.ASIN

Of course, using keys is still possible with ``response.parsed``. Further, as the keys, attrs, and ``dict.get()``
method all return the same content, these methods can all be mixed as needed:

.. code-block:: python

    asin = response.parsed['Products'].get('Product')[0].Identifiers['MarketplaceASIN'].get('ASIN')

While these still produce lengthy code lines, we can always assign chunks of the parsed document to a new variable:

.. code-block:: python

    product = response.parsed.Products.Product[0]
    asin = product.Identifiers.MarketplaceASIN.ASIN

Using the above pattern, breaking the document down in chunks, comes in handy as we get into additional features
of the parsed response below.

Iteration by default
====================

Sibling XML tags with the same tag name represent sequences of similar objects. When parsed to a Python dict,
they are collected into a list of dicts accessible from a key by the same name as the sibling tags.

For the following (simplified) XML document:

.. code-block:: xml

    <Response>
      <Products>
        <Product>
          <Name>spam</Name>
        </Product>
        <Product>
          <Name>ham</Name>
        </Product>
        <Product>
          <Name>eggs</Name>
        </Product>
      </Products>
    </Response>

Each ``<Product>`` tag's child nodes are parsed into a separate dict, and all dicts are joined in a list,
which you will find at ``response.parsed.Products.Product``. Typically, you will want to access these ``Product``
objects by iterating the ``Product`` node:

.. code-block:: python

    names = []
    for product in response.parsed.Products.Product:
        names.append(product.Name)

    print(names)
    # ['spam', 'ham', 'eggs']

If the same request returns only one ``<Product>`` tag, the ``Product`` key in the parsed response will return only
a single ``DotDict``, similar to any other node in the XML tree. Trying to access the ``Product`` node in this case
as though it were a list - such as using indices (``.Product[0]``) - will result in errors.

However, when a ``DotDict`` is iterated, it will wrap itself in a list in order to provide the same interface as before.

So, for an XML response like so:

.. code-block:: xml

    <Response>
      <Products>
        <Product>
          <Name>foo</Name>
        </Product>
      </Products>
    </Response>

...the same Python code can be used to access "all" ``Product`` keys:

.. code-block:: python

    names = []
    for product in response.parsed.Products.Product:
        names.append(product.Name)

    print(names)
    # ['foo']

.. note:: While ``DotDict`` is a subclass of ``dict``, this behavior is different from that of the standard ``dict``,
   where iterating directly on the ``dict`` object is equivalent to iterating on ``dict.keys()``. We have chosen to
   implement the above behavior to more closely match most users' intended usage when working with parsed XML,
   even though ``DotDict`` *can* be used much like a standard ``dict`` for (most) general purposes.

Working with tag attributes
===========================

XML content can contain attributes on tags, as well. These attributes are parsed as dict keys beginning
with ``@``, accessible as child nodes of the tag they appear on.

Further, tags that contain an attribute and text content will store the text on a special key, ``#text``.

Example:

.. code-block:: python

    from mws.utils.xml import mws_xml_to_dotdict

    content = """<Response>
      <Products>
        <Product Name="spam">
          <SomethingElse>ham</SomethingElse>
          <WhatHaveYou anotherAttr="foo">eggs</WhatHaveYou>
        </Product>
      </Products>
    </Response>
    """

    dotdict = mws_xml_to_dotdict(content)

    print(dotdict)
    # DotDict({'Products': DotDict({'Product': DotDict({'@Name': 'spam', 'SomethingElse': 'ham', 'WhatHaveYou': DotDict({'@anotherAttr': 'foo', '#text': 'eggs'})})})})

These ``@`` and ``#text`` keys cannot be accessed directly as attributes due to Python syntax, which reserves the
``@`` and ``#`` characters. You can still use standard dict keys to access this content:

.. code-block:: python

    print(dotdict.Products.Product['@Name'])
    # 'spam'

    print(dotdict.Products.Product.WhatHaveYou['#text'])
    # 'eggs'

``DotDict`` also allows accessing these keys using a fallback method. Simply provide the key name without
``@`` or ``#`` in front, and it will attempt to find a matching key:

.. code-block:: python

    print(dotdict.Products.Product.Name)
    # 'spam'

    print(dotdict.Products.Product.WhatHaveYou.text)
    # 'eggs'

.. note:: In case of a conflicting key name, a key matching the attribute will be returned first:

   .. code-block:: python

       dotdict = DotDict({'foo': 'spam', '@foo': 'ham'})
       print(dotdict.foo)
       # 'spam'
       print(dotdict['@foo'])
       # 'ham'

   This conflict is a rare occurrence for most XML documents, however, as they are not likely to return a tag attribute
   with the same name as an immediate child tag.

Root node, metadata, and stripped content
=========================================

MWS XML responses will typically take the following shape:

.. code-block:: xml

    <?xml version="1.0"?>
    <{Operation}Response xmlns="http://mws.amazonservices.com/...">
      <{Operation}Result>
        <!-- content of the response here -->
      </{Operation}Result>
      <ResponseMetadata>
        <RequestId>3b805a12-689a-4367-ba86-EXAMPLE91c0b</RequestId>
      </ResponseMetadata>
    </{Operation}Response>

This document will be "cleaned" in the following ways, in addition to the parsing performed by ``xmltodict``:

- `Namespaces <https://en.wikipedia.org/wiki/XML_namespace>`_ are stripped, so you will typically never find ``xmlns``
  attributes within the parsed document.
- The root tag of the document, ``<{Operation}Response>`` (where ``{Operation}`` is the name of the MWS operation
  requested), is ignored. The parsed ``dict`` of the above document would take the shape of
  ``{'{Operation}Result': ..., 'ResponseMetadata': ...}``, with no need to use a ``{Operation}Response`` key first.
- The **result key** - typically the ``<{Operation}Result>`` tag - will be used as the root node for
  ``response.parsed``. If the first child of this tag were, for instance, ``<Products>``, that can be accessed as
  ``response.parsed.Products``, with no need to specify ``{Operation}Result`` as a key first.
- The contents of ``<ResponseMetadata>`` can be accessed as a separate ``DotDict`` instance, by using
  ``MWSResponse.metadata``. As this node typically only contains the ``<RequestId>`` tag, this is also made available
  with property ``MWSResponse.request_id`` (returns ``None`` if not provided with this response).

- Tags and attributes may occasionally have names beginning with ``ns2:`` or ``xml:``. These prefixes will be stripped

  For instance:

  .. code-block:: xml

  <?xml version="1.0"?>
    <ListMatchingProductsResponse xmlns="http://mws.amazonservices.com/schema/Products/2011-10-01">
      <ListMatchingProductsResult>
        <Products xmlns="http://mws.amazonservices.com/schema/Products/2011-10-01" xmlns:ns2="http://mws.amazonservices.com/schema/Products/2011-10-01/default.xsd">
          <Product>
            <Identifiers>
              <MarketplaceASIN>
                <MarketplaceId>ATVPDKIKX0DER</MarketplaceId>
                <ASIN>059035342X</ASIN>
              </MarketplaceASIN>
            </Identifiers>
            <AttributeSets>
              <ns2:ItemAttributes xml:lang="en-US">
                <ns2:Binding>Paperback</ns2:Binding>
                <ns2:Brand>Scholastic Press</ns2:Brand>
                <ns2:Creator Role="Illustrator">GrandPrÃ©, Mary</ns2:Creator>
              </ns2:ItemAttributes>
            </AttributeSets>
            <Relationships/>
          </Product>
        </Products>
      </ListMatchingProductsResult>
      <ResponseMetadata>
        <RequestId>3b805a12-689a-4367-ba86-EXAMPLE91c0b</RequestId>
      </ResponseMetadata>
    </ListMatchingProductsResponse>

**TODO complete this!**

Example parsed response
=======================

Below is an example response from the Products API operation `ListMatchingProducts
<http://docs.developer.amazonservices.com/en_US/products/Products_ListMatchingProducts.html>`_,
as provided in MWS documentation and modified for length:

.. code-block:: xml

    <?xml version="1.0"?>
    <ListMatchingProductsResponse xmlns="http://mws.amazonservices.com/schema/Products/2011-10-01">
      <ListMatchingProductsResult>
        <Products xmlns="http://mws.amazonservices.com/schema/Products/2011-10-01" xmlns:ns2="http://mws.amazonservices.com/schema/Products/2011-10-01/default.xsd">
          <Product>
            <Identifiers>
              <MarketplaceASIN>
                <MarketplaceId>ATVPDKIKX0DER</MarketplaceId>
                <ASIN>059035342X</ASIN>
              </MarketplaceASIN>
            </Identifiers>
            <AttributeSets>
              <ns2:ItemAttributes xml:lang="en-US">
                <ns2:Binding>Paperback</ns2:Binding>
                <ns2:Brand>Scholastic Press</ns2:Brand>
                <ns2:Creator Role="Illustrator">GrandPrÃ©, Mary</ns2:Creator>
              </ns2:ItemAttributes>
            </AttributeSets>
            <Relationships/>
          </Product>
        </Products>
      </ListMatchingProductsResult>
      <ResponseMetadata>
        <RequestId>3b805a12-689a-4367-ba86-EXAMPLE91c0b</RequestId>
      </ResponseMetadata>
    </ListMatchingProductsResponse>

``response.parsed`` will always start from the ``<operation>Result`` node as its "root":
in this case, ``ListMatchingProductsResult``.

To access, for instance, the ASINs of all Products returned by this request, we might
do the following:

.. code-block:: python

    products = response.parsed.Products.Product
    # Don't be afraid to re-assign sub-nodes for readability!

    asins = []
    for product in products:
        # Each `product` here begins from a `<Product>` tag in the XML
        this_asin = product.Identifiers.MarketplaceASIN.ASIN
        asins.append(this_asin)

    print(asins)
    # ['059035342X']

Going further, let's process some of the ``ItemAttributes`` available:

.. code-block:: python

    products = response.parsed.Products.Product
    for product in products:
        attributes = product.AttributeSets.ItemAttributes
        # This accesses the XML tag `<ns2:ItemAttributes>`
        # Note the `ns2:` prefix is stripped from this and all sub-nodes.

        creator_tag = attributes.Creator
        # `<ns2:Creator>` contains a "Role" attribute as well as a value.
        # Thus, the return value of `.Creator` is another `DotDict` containing both.

        role = creator_tag.Role
        # We access `Role` as though it were another child node.

        creator = creator_tag.value
        # The tag contents are stored in `.value`.

        print(role)
        # Illustrator

        print(creator)
        # GrandPrÃ©, Mary
